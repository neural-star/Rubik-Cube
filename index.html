<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rubik's Cube Pattern Timer — Pro</title>
  <style>
    /* =====================
       THEME SYSTEM
       ===================== */
    :root {
      --bg: #ffffff;
      --fg: #2d3748;
      --muted: #4a5568;
      --accent: #4299e1;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --card: #f7fafc;
      --border: #e2e8f0;
    }
    /* Dark theme */
    .theme-dark {
      --bg: #0b1220;
      --fg: #e2e8f0;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --good: #22c55e;
      --warn: #f59e0b;
      --bad: #ef4444;
      --card: #0f172a;
      --border: #1f2942;
    }
    /* Colorful theme */
    .theme-fun {
      --bg: #fffaf0;
      --fg: #1f2937;
      --muted: #6b7280;
      --accent: #f97316; /* orange */
      --good: #16a34a;
      --warn: #eab308;
      --bad: #ef4444;
      --card: #fff5e7;
      --border: #f3d7b6;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";
      background: var(--bg);
      color: var(--fg); display: grid; place-items: center; padding: 24px;
      transition: background 0.5s ease, color 0.5s ease;
    }
    .app { width: min(1280px, 96vw); display: grid; gap: 16px; }

    .topbar { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .badge { font-size: 12px; color: var(--muted); }

    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .toolbar .group { display: flex; gap: 8px; align-items: center; background: var(--card); border: 1px solid var(--border); padding: 6px 8px; border-radius: 10px; }
    .toolbar label { font-size: 12px; color: var(--muted); }
    .toolbar input[type="number"], .toolbar select, .toolbar input[type="range"] {
      background: transparent; color: var(--fg); border: 1px solid var(--border); padding: 6px 8px; border-radius: 8px;
    }

    /* Ensure range is easily reachable and sized */
    .toolbar input[type="range"] { width: 160px; min-width: 100px; }

    .mode-selector { display: flex; gap: 8px; background: var(--card); border-radius: 12px; padding: 4px; border: 1px solid var(--border); }
    .mode-btn { padding: 8px 16px; border-radius: 8px; background: transparent; color: var(--muted); border: none; cursor: pointer; transition: all 0.2s; font-weight: 500; }
    .mode-btn.active { background: var(--accent); color: var(--bg); font-weight: 600; }

    .scramble { width: 100%; background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 14px 18px; font-size: clamp(16px, 1.6vw, 20px); letter-spacing: 0.4px; line-height: 1.5; color: var(--fg); transition: background 0.5s ease, color 0.5s ease, border-color 0.5s ease; }

    .pattern-section { display: none; background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 16px; transition: background 0.5s ease, border-color 0.5s ease; }
    .pattern-section.active { display: block; }
    .pattern-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 8px; }
    .pattern-title { font-weight: 600; color: var(--accent); transition: color 0.5s ease; }
    .pattern-info { font-size: 12px; color: var(--muted); transition: color 0.5s ease; }

    .pattern-controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }

    .cube-net { display: grid; grid-template-areas: ". top . ." "left front right back" ". bottom . ."; gap: 2px; justify-content: center; margin: 16px 0; }
    .face { width: 60px; height: 60px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; border: 2px solid #4a5568; border-radius: 4px; }
    .face.top { grid-area: top; }
    .face.left { grid-area: left; }
    .face.front { grid-area: front; }
    .face.right { grid-area: right; }
    .face.back { grid-area: back; }
    .face.bottom { grid-area: bottom; }

    .sticker { border-radius: 2px; border: 1px solid rgba(0,0,0,0.3); }
    .sticker.W { background: #fff; }
    .sticker.R { background: #ff4444; }
    .sticker.G { background: #22c55e; }
    .sticker.B { background: #3b82f6; }
    .sticker.O { background: #ff8800; }
    .sticker.Y { background: #eab308; }

    .timer { user-select: none; text-align: center; border-radius: 24px; padding: 28px 20px; background: var(--card); border: 1px solid var(--border); box-shadow: 0 10px 30px rgba(0,0,0,0.1); transition: background 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease; cursor: pointer; touch-action: none; }
    .time { font-variant-numeric: tabular-nums; font-weight: 700; letter-spacing: 1px; font-size: clamp(64px, 13vw, 140px); line-height: 1; margin: 10px 0 8px; transition: color .15s ease; }
    .time.ready { color: var(--good); }
    .time.inspect { color: var(--warn); }
    .time.beep { filter: drop-shadow(0 0 10px rgba(255,255,255,.35)); }

    .controls { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; }
    button {background: var(--card); color: var(--fg); border: 1px solid var(--border); padding: 10px 14px; border-radius: 14px; font-weight: 600; cursor: pointer; transition: transform .05s ease, filter .15s ease, background .2s ease; font-size: 14px;}
    button:hover { filter: brightness(0.95); }
    button:active { transform: translateY(1px); }

    /* Use theme-aware card color for toggles (fixes dark-mode text visibility) */
    .toggle { background: var(--card); color: var(--fg); border: 1px solid var(--border); }

    .grid { display: grid; grid-template-columns: 1.2fr .8fr; gap: 16px; }
    @media (max-width: 980px){ .grid { grid-template-columns: 1fr; } }

    .panel { background: var(--card); border: 1px solid var(--border); border-radius: 16px; padding: 16px; transition: background 0.5s ease, border-color 0.5s ease; }

    .stats { display: grid; grid-template-columns: repeat(6, 1fr); gap: 10px; margin-top: 10px; }
    .stat { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 10px; transition: background 0.5s ease, border-color 0.5s ease; }
    .theme-dark .stat { background: #0b162e; }
    .stat .label { color: var(--muted); font-size: 12px; transition: color 0.5s ease; }
    .stat .value { font-variant-numeric: tabular-nums; font-size: 18px; font-weight: 700; margin-top: 6px; transition: color 0.5s ease; }

    .session h3 { margin: 0 0 8px; font-size: 16px; color: var(--muted); }
    .times { max-height: 320px; overflow: auto; border-top: 1px dashed #26314d; margin-top: 8px; padding-top: 8px; }
    .time-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; padding: 6px 0; border-bottom: 1px dashed #1d2744; font-variant-numeric: tabular-nums; }
    .time-row:last-child { border-bottom: none; }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid #2b3753; color: var(--muted); white-space: nowrap; }

    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 2px 6px; font-size: 12px; color: var(--muted); }

    .pattern-difficulty { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .difficulty-btn { padding: 4px 12px; border-radius: 12px; background: var(--card); color: var(--fg); border: 1px solid var(--border); cursor: pointer; font-size: 12px; transition: all 0.2s; }
    .difficulty-btn.active { background: var(--accent); color: #ffffff; border-color: var(--accent); }

    /* Chart */
    .chart-wrap { margin-top: 12px; }
    canvas { width: 100%; height: 220px; display: block; border-radius: 12px; background: var(--bg); border: 1px solid var(--border); }

    /* Tables */
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { padding: 8px 10px; border-bottom: 1px dashed var(--border); text-align: left; }
    th { color: var(--muted); font-weight: 600; }

    .goal-ok { color: var(--good); font-weight: 700; }
    .goal-ng { color: var(--bad); font-weight: 700; }

    /* Celebration overlay + confetti */
    .celebrate-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 9999; overflow: hidden; }
    .celebration-text { position: absolute; top: 18%; left: 50%; transform: translateX(-50%); font-size: 36px; font-weight: 800; color: var(--accent); text-shadow: 0 6px 20px rgba(0,0,0,0.45); }
    .confetti-piece { position: absolute; width: 10px; height: 14px; border-radius: 2px; opacity: 0.95; transform-origin: center; animation: confetti-fall 2000ms linear forwards; }
    @keyframes confetti-fall { to { transform: translateY(110vh) rotate(720deg); opacity: 0; } }

    .select {
    padding: 6px 14px;
    border-radius: 12px;
    background: var(--card);
    color: var(--fg);
    border: 1px solid var(--border);
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
  }
    input[type="range"] {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    width: 100%;
    margin: 0;
    padding: 0;
    background: var(--card);
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--fg);
    border-radius: 30%;
    cursor: pointer;
    margin-top: -3px;
  }

  input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: var(--fg);
    border-radius: 50%;
    cursor: pointer;
  }

  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <span class="badge">スペース長押し → 離してスタート / もう一度でストップ</span>
      <span class="badge">ショートカット: <span class="kbd">N</span> 新規生成, <span class="kbd">T</span> 検討15s, <span class="kbd">D</span> 直前を削除, <span class="kbd">R</span> クリア</span>
    </div>

    <div class="toolbar">
      <div class="group">
        <label>テーマ</label>
        <select id="themeSel">
          <option value="light" class="select">ライト</option>
          <option value="dark" class="select">ダーク</option>
          <option value="fun" class="select">オレンジ</option>
        </select>
      </div>
      <div class="group">
        <label>目標タイム (秒)</label>
        <input id="goalInput" type="number" step="0.01" min="0" placeholder="例: 15.00" style="width:110px"/>
        <span id="goalStatus" class="badge">未設定</span>
      </div>
      <div class="group" style="gap:12px;">
        <label>スクランブル長</label>
        <input id="scrLen" type="range" min="0" max="90" value="30" step="1" />
        <span id="scrLenVal" class="badge"></span>
      </div>
      <div class="group">
        <label>祝福</label>
        <input id="celebrateChk" type="checkbox" title="ベスト/目標達成時に祝う" />
      </div>
      <div class="mode-selector" style="margin-left:auto;">
        <button class="mode-btn active" data-mode="normal">通常モード</button>
        <button class="mode-btn" data-mode="pattern">パターンモード</button>
      </div>
    </div>

    <div class="scramble" id="scramble">-</div>

    <div class="pattern-section" id="patternSection">
      <div class="pattern-header">
        <div class="pattern-title">目標パターン</div>
        <div class="pattern-info">このパターンに合わせてください</div>
      </div>

      <div class="pattern-controls">
        <div class="pattern-difficulty">
          <button class="difficulty-btn active" data-difficulty="easy">簡単 (2-3色)</button>
          <button class="difficulty-btn" data-difficulty="medium">普通 (4-5色)</button>
          <button class="difficulty-btn" data-difficulty="hard">難しい (全色)</button>
        </div>
        <div class="group">
          <label>練習セット</label>
          <select id="practiceSet" class="select">
            <option value="free">自由練習</option>
            <option value="oll">OLL</option>
            <option value="pll">PLL</option>
            <option value="f2l">F2L</option>
          </select>
        </div>
        <button id="btnHint" class="toggle">ヒント表示</button>
      </div>

      <div class="cube-net" id="cubeNet"></div>
      <div id="hintBox" class="panel" style="display:none; font-size:14px;">
        <strong>ヒント:</strong>
        <div id="hintText" style="margin-top:6px; white-space:pre-wrap;"></div>
      </div>
    </div>

    <div class="timer">
      <div id="bigTime" class="time">0.000</div>
      <div class="controls">
        <button id="btnNew">新規生成</button>
        <button id="btnToggleInsp" class="toggle">検討15秒: <span id="inspState">OFF</span></button>
        <button id="btnDelete">直前を削除</button>
        <button id="btnClear">セッションをクリア</button>
        <button id="btnExport">CSVエクスポート</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel session">
        <h3>セッション (<span id="currentMode">通常</span>)</h3>
        <div class="stats">
          <div class="stat"><div class="label">計測回数</div><div class="value" id="statCount">0</div></div>
          <div class="stat"><div class="label">ベスト</div><div class="value" id="statBest">-</div></div>
          <div class="stat"><div class="label">平均 (全体)</div><div class="value" id="statAvg">-</div></div>
          <div class="stat"><div class="label">Ao5 / Ao12</div><div class="value" id="statAos">- / -</div></div>
          <div class="stat"><div class="label">Mo3</div><div class="value" id="statMo3">-</div></div>
          <div class="stat"><div class="label">Ao50 / Ao100</div><div class="value" id="statLong">- / -</div></div>
        </div>
        <div class="chart-wrap">
          <canvas id="chart"></canvas>
        </div>
        <div class="times" id="times"></div>
      </div>

      <div class="panel">
        <h3>分析・比較</h3>
        <div style="display:grid; gap:12px;">
          <div>
            <strong>目標達成状況:</strong>
            <div id="goalSummary" class="badge">未設定</div>
          </div>
          <div>
            <strong>ベストタイム履歴:</strong>
            <div id="pbList" class="badge">—</div>
          </div>
          <div>
            <strong>日付別サマリ (本モード):</strong>
            <table id="byDateTable"><thead><tr><th>日付</th><th>回数</th><th>平均</th><th>ベスト</th></tr></thead><tbody></tbody></table>
          </div>
          <div>
            <strong>モード比較 (平均):</strong>
            <table id="byModeTable"><thead><tr><th>モード</th><th>回数</th><th>平均</th><th>ベスト</th></tr></thead><tbody></tbody></table>
          </div>
        </div>
        <div style="margin-top:10px;">
          <h3>使い方</h3>
          <p><strong>通常モード:</strong> 従来のスピードキューブタイマー。全面を揃えるタイムを測定。</p>
          <p><strong>パターンモード:</strong> ランダム生成されたパターン / 練習セット（OLL/PLL/F2L）からケースを出題。展開図とヒントを参考に再現してください。</p>
          <p>スペースキーを<strong>500ms以上長押し</strong>すると準備（緑表示）。離すとスタート。もう一度スペースでストップ。</p>
          <p>検討ONの場合は15秒のカウントダウン後に自動スタートします。</p>
          <p>ショートカット: <span class="kbd">N</span> 新規生成, <span class="kbd">T</span> 検討切替, <span class="kbd">D</span> 直前削除, <span class="kbd">R</span> セッションクリア</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Celebration container (appended/used by JS) -->
  <div id="celebrateRoot" class="celebrate-overlay" style="display:none"></div>

  <script>
    // ===================== Utilities =====================
    const fmt = (ms) => { if (!isFinite(ms)) return '-'; const s = ms / 1000; return s.toFixed(3); };
    const fmtS = (s) => isFinite(s) ? s.toFixed(3) : '-';
    const dl = (filename, text) => { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([text], { type: 'text/csv' })); a.download = filename; a.click(); URL.revokeObjectURL(a.href); };

    // Simple beep generator
    const beeper = (() => {
      let ctx; const ensure = () => (ctx ||= new (window.AudioContext || window.webkitAudioContext)());
      const beep = (freq=880, dur=120) => { try { const ac = ensure(); const o = ac.createOscillator(); const g = ac.createGain(); o.connect(g); g.connect(ac.destination); o.frequency.value = freq; o.type = 'sine'; const t = ac.currentTime; g.gain.setValueAtTime(0.001, t); g.gain.exponentialRampToValueAtTime(0.6, t + 0.01); g.gain.exponentialRampToValueAtTime(0.0001, t + dur/1000); o.start(t); o.stop(t + dur/1000 + 0.02);} catch {} };
      return { beep };
    })();

    // ===================== Scrambler (3x3) =====================
    const faces = ['U','R','F','D','L','B'];
    const mods = ['', "'", '2'];
    const axisOf = { U:'y', D:'y', L:'x', R:'x', F:'z', B:'z' };
    function genScramble(n){
      const len = Number(localStorage.getItem('cube.scrLen')||n||25);
      let res = [], prevAxis = null, prevFace = null;
      while (res.length < len){
        const f = faces[Math.floor(Math.random()*faces.length)];
        if (axisOf[f] === prevAxis) continue;
        if (f === prevFace) continue;
        const m = mods[Math.floor(Math.random()*mods.length)];
        res.push(f + m); prevAxis = axisOf[f]; prevFace = f;
      }
      return res.join(' ');
    }

    // ===================== Pattern Generator =====================
    const colors = ['W','R','G','B','O','Y'];
    function getSolvedCube() {
      return { top:Array(9).fill('W'), left:Array(9).fill('O'), front:Array(9).fill('G'), right:Array(9).fill('R'), back:Array(9).fill('B'), bottom:Array(9).fill('Y') };
    }

    function applyMove(cube, move) {
      const result = JSON.parse(JSON.stringify(cube));
      const face = move[0]; const modifier = move.slice(1);
      const cw = (f)=>{ const t=[...f]; return [t[6],t[3],t[0], t[7],t[4],t[1], t[8],t[5],t[2]]; };
      let rotations = 1; if (modifier === "'") rotations = 3; if (modifier === '2') rotations = 2;
      for (let i=0;i<rotations;i++){
        if (face==='U'){
          result.top = cw(result.top);
          const temp = [result.front[0],result.front[1],result.front[2]];
          [result.front[0],result.front[1],result.front[2]] = [result.right[0],result.right[1],result.right[2]];
          [result.right[0],result.right[1],result.right[2]] = [result.back[0],result.back[1],result.back[2]];
          [result.back[0],result.back[1],result.back[2]] = [result.left[0],result.left[1],result.left[2]];
          [result.left[0],result.left[1],result.left[2]] = temp;
        } else if (face==='D'){
          result.bottom = cw(result.bottom);
          const temp = [result.front[6],result.front[7],result.front[8]];
          [result.front[6],result.front[7],result.front[8]] = [result.left[6],result.left[7],result.left[8]];
          [result.left[6],result.left[7],result.left[8]] = [result.back[6],result.back[7],result.back[8]];
          [result.back[6],result.back[7],result.back[8]] = [result.right[6],result.right[7],result.right[8]];
          [result.right[6],result.right[7],result.right[8]] = temp;
        } else if (face==='R'){
          result.right = cw(result.right);
          const temp = [result.top[2],result.top[5],result.top[8]];
          [result.top[2],result.top[5],result.top[8]] = [result.front[2],result.front[5],result.front[8]];
          [result.front[2],result.front[5],result.front[8]] = [result.bottom[2],result.bottom[5],result.bottom[8]];
          [result.bottom[2],result.bottom[5],result.bottom[8]] = [result.back[6],result.back[3],result.back[0]];
          [result.back[6],result.back[3],result.back[0]] = temp;
        } else if (face==='L'){
          result.left = cw(result.left);
          const temp = [result.top[0],result.top[3],result.top[6]];
          [result.top[0],result.top[3],result.top[6]] = [result.back[8],result.back[5],result.back[2]];
          [result.back[8],result.back[5],result.back[2]] = [result.bottom[0],result.bottom[3],result.bottom[6]];
          [result.bottom[0],result.bottom[3],result.bottom[6]] = [result.front[0],result.front[3],result.front[6]];
          [result.front[0],result.front[3],result.front[6]] = temp;
        } else if (face==='F'){
          result.front = cw(result.front);
          const temp = [result.top[6],result.top[7],result.top[8]];
          [result.top[6],result.top[7],result.top[8]] = [result.left[8],result.left[5],result.left[2]];
          [result.left[8],result.left[5],result.left[2]] = [result.bottom[2],result.bottom[1],result.bottom[0]];
          [result.bottom[2],result.bottom[1],result.bottom[0]] = [result.right[0],result.right[3],result.right[6]];
          [result.right[0],result.right[3],result.right[6]] = temp;
        } else if (face==='B'){
          result.back = cw(result.back);
          const temp = [result.top[0],result.top[1],result.top[2]];
          [result.top[0],result.top[1],result.top[2]] = [result.right[2],result.right[5],result.right[8]];
          [result.right[2],result.right[5],result.right[8]] = [result.bottom[8],result.bottom[7],result.bottom[6]];
          [result.bottom[8],result.bottom[7],result.bottom[6]] = [result.left[6],result.left[3],result.left[0]];
          [result.left[6],result.left[3],result.left[0]] = temp;
        }
      }
      return result;
    }

    function applyScramble(cube, scrambleStr) { return scrambleStr.split(' ').filter(m=>m.trim()).reduce((c,m)=>applyMove(c,m.trim()), cube); }

    function generateRandomPattern(difficulty = 'medium') {
      let scrambleLength; switch(difficulty){ case 'easy': scrambleLength = 10; break; case 'medium': scrambleLength = 18; break; case 'hard': scrambleLength = 28; break; default: scrambleLength = 18; }
      const scrambleForPattern = genScramble(scrambleLength);
      const scrambledCube = applyScramble(getSolvedCube(), scrambleForPattern);
      return { pattern: scrambledCube, generatingScramble: scrambleForPattern };
    }

    function renderCubeNet(pattern) {
      const cubeNet = document.getElementById('cubeNet'); cubeNet.innerHTML = '';
      const faceOrder = ['top', 'left', 'front', 'right', 'back', 'bottom'];
      faceOrder.forEach(faceName => { const faceDiv = document.createElement('div'); faceDiv.className = `face ${faceName}`; pattern[faceName].forEach(color => { const sticker = document.createElement('div'); sticker.className = `sticker ${color}`; faceDiv.appendChild(sticker); }); cubeNet.appendChild(faceDiv); });
    }

    // ===================== Practice Sets (sample) =====================
    const PRACTICE_DB = {
      oll: [
        { name: 'OLL 1 (Sune)', alg: "R U R' U R U2 R'", hint: '右上を軸に3回のUで上面を揃える定番ケース。' },
        { name: 'OLL 2 (Anti-Sune)', alg: "R U2 R' U' R U' R'", hint: '逆スーン。U2から始まる。' },
        { name: 'OLL 27', alg: "R U R' U' R U' R' F' U' F R U R'", hint: 'T字を作ってからF挿入。' },
      ],
      pll: [
        { name: 'PLL T', alg: "R U R' U' R' F R2 U' R' U' R U R' F'", hint: '前面の2点交換。実戦で頻出。' },
        { name: 'PLL U (a)', alg: "R U' R U R U R U' R' U' R2", hint: '上面の三点交換（時計回り）。' },
        { name: 'PLL J (a)', alg: "R U R' F' R U R' U' R' F R2 U' R' U'", hint: 'コーナーとエッジの交換。' },
      ],
      f2l: [
        { name: 'F2L 基本1', alg: "U R U' R'", hint: '白を下にキープしたままペアを挿入。' },
        { name: 'F2L 基本2', alg: "U' F' U F", hint: '左手での基本インサート。' },
        { name: 'F2L スロット跨ぎ', alg: "y U R U' R' y'", hint: '視線移動を減らす回転を意識。' },
      ]
    };

    // ===================== State =====================
    const el = (id) => document.getElementById(id);
    const big = el('bigTime');
    const timesEl = el('times');
    const scrambleEl = el('scramble');
    const inspStateEl = el('inspState');
    const patternSection = el('patternSection');
    const currentModeEl = el('currentMode');
    const goalInput = el('goalInput');
    const goalStatus = el('goalStatus');
    const goalSummary = el('goalSummary');
    const scrLen = el('scrLen');
    const scrLenVal = el('scrLenVal');
    const chartCanvas = el('chart');

    let currentMode = localStorage.getItem('cube.mode') || 'normal'; // 'normal' or 'pattern'
    let currentDifficulty = localStorage.getItem('cube.diff') || 'easy';
    let currentPattern = null;
    let practiceSet = localStorage.getItem('cube.practiceSet') || 'free';
    let session = JSON.parse(localStorage.getItem(`cube.session.${currentMode}`) || '[]');
    let inspectOn = JSON.parse(localStorage.getItem('cube.inspectOn') || 'false');
    let goalTime = parseFloat(localStorage.getItem('cube.goal') || 'NaN');
    let theme = localStorage.getItem('cube.theme') || 'light';
    let scrLenValStore = parseInt(localStorage.getItem('cube.scrLen') || '25', 10);
    let celebrateOn = JSON.parse(localStorage.getItem('cube.celebrate') || 'true');

    let state = 'idle'; // idle | hold | ready | inspect | running
    let t0 = 0, raf = 0, holdTimer = 0, inspectEnd = 0, currentScramble = '';

    // ===================== Theme & Controls =====================
    const applyTheme = (t) => {
      document.body.classList.remove('theme-dark','theme-fun');
      if (t==='dark') document.body.classList.add('theme-dark');
      if (t==='fun') document.body.classList.add('theme-fun');
      localStorage.setItem('cube.theme', t);
    };

    const themeSel = document.getElementById('themeSel');
    themeSel.value = theme; applyTheme(theme);
    themeSel.addEventListener('change', ()=>{ theme = themeSel.value; applyTheme(theme); drawChart(); });

    const updateScrLenUI = ()=>{ scrLen.value = scrLenValStore; scrLenVal.textContent = scrLenValStore + ' 手'; };
    updateScrLenUI();
    scrLen.addEventListener('input', ()=>{ scrLenValStore = parseInt(scrLen.value,10); localStorage.setItem('cube.scrLen', scrLenValStore); updateScrLenUI(); });

    if (!isNaN(goalTime)) goalInput.value = goalTime.toFixed(2);
    const updateGoalStatus = ()=>{ if (isNaN(goalTime)) { goalStatus.textContent = '未設定'; return; } goalStatus.textContent = `${goalTime.toFixed(2)}s 目標`; };
    updateGoalStatus();
    goalInput.addEventListener('change', ()=>{ goalTime = parseFloat(goalInput.value); if (isNaN(goalTime)) { localStorage.removeItem('cube.goal'); } else { localStorage.setItem('cube.goal', String(goalTime)); } updateGoalStatus(); renderAnalysis(); });

    // Celebration toggle init
    const celebrateChk = el('celebrateChk');
    celebrateChk.checked = celebrateOn;
    celebrateChk.addEventListener('change', ()=>{ celebrateOn = celebrateChk.checked; localStorage.setItem('cube.celebrate', JSON.stringify(celebrateOn)); });

    // ===================== Rendering =====================
    function renderTimes(){
      timesEl.innerHTML = '';
      session.slice().reverse().forEach((it, idx) => {
        const div = document.createElement('div');
        div.className = 'time-row';
        const n = session.length - idx;
        const challengeText = it.challenge || it.scramble;
        const goalClass = (!isNaN(goalTime) && it.ms/1000 <= goalTime) ? 'goal-ok' : '';
        div.innerHTML = `<span>#${n}</span><span class="${goalClass}">${fmt(it.ms)} s</span><span class="pill">${challengeText}</span>`;
        timesEl.appendChild(div);
      });
      el('statCount').textContent = String(session.length);
      el('statBest').textContent = session.length ? fmt(Math.min(...session.map(t=>t.ms))) + ' s' : '-';
      el('statAvg').textContent = session.length ? fmt(avg(session.map(t=>t.ms))) + ' s' : '-';
      const a5 = averageTrimmed(5), a12 = averageTrimmed(12);
      el('statAos').textContent = `${a5 ? fmt(a5)+ ' s' : '-'} / ${a12 ? fmt(a12) + ' s' : '-'}`;
      el('statMo3').textContent = mo3() ? fmt(mo3()) + ' s' : '-';
      const a50 = averageTrimmed(50, true); const a100 = averageTrimmed(100, true);
      el('statLong').textContent = `${a50 ? fmt(a50)+ ' s' : '-'} / ${a100 ? fmt(a100) + ' s' : '-'}`;
      drawChart();
    }

    function avg(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }

    function mo3(){ if (session.length < 3) return null; const arr = session.slice(-3).map(x=>x.ms); return avg(arr); }

    // WCA風トリム平均: N<=12 は両端1つずつ除外、それ以上は5%切り捨て
    function averageTrimmed(n, pct=false){ if (session.length < n) return null; const lastN = session.slice(-n).map(t=>t.ms).slice(); lastN.sort((a,b)=>a-b); let drop = 1; if (pct && n>12) drop = Math.max(1, Math.floor(n*0.05)); const trimmed = lastN.slice(drop, lastN.length-drop); if (!trimmed.length) return null; return avg(trimmed); }

    function setInspect(on){ inspectOn = !!on; localStorage.setItem('cube.inspectOn', JSON.stringify(inspectOn)); inspStateEl.textContent = inspectOn ? 'ON' : 'OFF'; }

    function generateNew(){
      if (currentMode === 'normal') {
        currentScramble = genScramble(25);
        scrambleEl.textContent = currentScramble;
      } else if (currentMode === 'pattern') {
        // Practice set handling
        let infoHTML = '';
        if (practiceSet !== 'free'){
          const list = PRACTICE_DB[practiceSet];
          const pick = list[Math.floor(Math.random()*list.length)];
          infoHTML += `<div style="margin-bottom:8px;"><strong>練習ケース:</strong> ${pick.name}</div>`;
          // Show hint if opened
          currentPattern = getSolvedCube(); // Keep solved diagram for clarity
          renderCubeNet(currentPattern);
          el('hintText').textContent = `${pick.name}\nAlg: ${pick.alg}\n${pick.hint||''}`;
          if (hintOpen) el('hintBox').style.display='block';
        } else {
          const patternData = generateRandomPattern(currentDifficulty);
          currentPattern = patternData.pattern; renderCubeNet(currentPattern);
          infoHTML += `<div style="font-size: 0.9em; color: var(--muted);"><strong>パターン生成:</strong> ${patternData.generatingScramble}</div>`;
        }
        currentScramble = genScramble(25);
        scrambleEl.innerHTML = `<div style="margin-bottom:8px;"><strong>スタート用スクランブル:</strong> ${currentScramble}</div>${infoHTML}`;
      }
    }

    function renderAnalysis(){
      // Goal progress
      if (isNaN(goalTime) || !session.length){ goalSummary.textContent = '未設定'; }
      else {
        const times = session.map(s=>s.ms/1000);
        const under = times.filter(t=>t <= goalTime).length;
        const pct = Math.round(under*100/times.length);
        const recent = times.slice(-20);
        const underRecent = recent.filter(t=>t<=goalTime).length;
        goalSummary.innerHTML = `達成: <span class="goal-ok">${under}/${times.length} (${pct}%)</span> / 直近20: <span class="goal-ok">${underRecent}/${recent.length}</span>`;
      }

      // PB history
      const key = `cube.pb.${currentMode}`;
      const pbList = JSON.parse(localStorage.getItem(key) || '[]');
      const pbBox = document.getElementById('pbList');
      if (!pbList.length) pbBox.textContent = '—'; else pbBox.innerHTML = pbList.map(p=>`${new Date(p.at).toLocaleString()} — <strong>${fmt(p.ms)}s</strong>`).join('<br>');

      // By-date table (for current mode)
      const tbody = document.querySelector('#byDateTable tbody'); tbody.innerHTML = '';
      const byDate = {};
      session.forEach(r=>{ const d = new Date(r.at); const key = d.getFullYear()+ '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0'); (byDate[key] ||= []).push(r.ms); });
      Object.entries(byDate).sort((a,b)=>a[0]<b[0]?-1:1).forEach(([d, arr])=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${d}</td><td>${arr.length}</td><td>${fmt(avg(arr))}</td><td>${fmt(Math.min(...arr))}</td>`; tbody.appendChild(tr);
      });

      // Mode comparison
      const modes = ['normal','pattern'];
      const tbodyM = document.querySelector('#byModeTable tbody'); tbodyM.innerHTML = '';
      modes.forEach(m=>{ const s = JSON.parse(localStorage.getItem(`cube.session.${m}`)||'[]'); if (!s.length) return; const arr = s.map(x=>x.ms); const tr=document.createElement('tr'); const name = (m==='normal'?'通常':'パターン'); tr.innerHTML = `<td>${name}</td><td>${s.length}</td><td>${fmt(avg(arr))}</td><td>${fmt(Math.min(...arr))}</td>`; tbodyM.appendChild(tr); });
    }

    // ===================== Chart =====================
    let chartCtx = chartCanvas.getContext('2d');
    function drawChart(){
      const w = chartCanvas.clientWidth, h = chartCanvas.clientHeight; chartCanvas.width = w * devicePixelRatio; chartCanvas.height = h * devicePixelRatio; chartCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      chartCtx.clearRect(0,0,w,h);
      const data = session.map(s=>s.ms/1000);
      if (!data.length){ chartCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--muted'); chartCtx.fillText('データなし', 12, 20); return; }
      const padding = {l:40, r:12, t:8, b:24};
      const xs = (i)=> padding.l + (w - padding.l - padding.r) * (i/(data.length-1||1));
      const min = Math.min(...data), max = Math.max(...data);
      const yMin = Math.floor((min-0.1)*10)/10; const yMax = Math.ceil((max+0.1)*10)/10;
      const ys = (v)=> padding.t + (h - padding.t - padding.b) * (1 - (v - yMin)/(yMax-yMin||1));
      // grid
      chartCtx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border'); chartCtx.lineWidth = 1; chartCtx.beginPath();
      for (let g=0; g<=5; g++){ const y = padding.t + (h - padding.t - padding.b) * (g/5); chartCtx.moveTo(padding.l, y); chartCtx.lineTo(w - padding.r, y); }
      chartCtx.stroke();
      // line
      chartCtx.beginPath(); chartCtx.lineWidth = 2; chartCtx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--accent');
      data.forEach((v,i)=>{ const x = xs(i), y = ys(v); if (i===0) chartCtx.moveTo(x,y); else chartCtx.lineTo(x,y); }); chartCtx.stroke();
      // moving average (last 5)
      if (data.length>=5){ const ma = []; for (let i=0;i<data.length;i++){ const s = Math.max(0,i-4); const sub = data.slice(s,i+1); ma.push(sub.reduce((a,b)=>a+b,0)/sub.length); }
        chartCtx.beginPath(); chartCtx.lineWidth = 2; chartCtx.setLineDash([4,4]); chartCtx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--muted');
        ma.forEach((v,i)=>{ const x = xs(i), y = ys(v); if (i===0) chartCtx.moveTo(x,y); else chartCtx.lineTo(x,y); }); chartCtx.stroke(); chartCtx.setLineDash([]);
      }
      // axes labels
      chartCtx.fillStyle = getComputedStyle(document.body).getPropertyValue('--muted'); chartCtx.font = '12px sans-serif';
      chartCtx.fillText(`${yMax.toFixed(2)}s`, 4, ys(yMax)+4); chartCtx.fillText(`${yMin.toFixed(2)}s`, 4, ys(yMin)+4);
    }

    // ===================== PB tracking =====================
    function recordPBIfNeeded(ms){
      const key = `cube.pb.${currentMode}`; const hist = JSON.parse(localStorage.getItem(key)||'[]');
      const best = session.length ? Math.min(...session.map(s=>s.ms)) : Infinity;
      if (!hist.length || ms <= Math.min(...hist.map(h=>h.ms))){ hist.push({ ms, at: Date.now() }); localStorage.setItem(key, JSON.stringify(hist)); }
    }

    // ===================== Celebration =====================
    const celebrateRoot = el('celebrateRoot');
    function rand(min,max){ return Math.random()*(max-min)+min; }
    function showCelebration(message){
      if (!celebrateOn) return;
      celebrateRoot.innerHTML = '';
      celebrateRoot.style.display = 'block';
      // message
      const txt = document.createElement('div'); txt.className = 'celebration-text'; txt.textContent = message; celebrateRoot.appendChild(txt);
      // confetti pieces
      const colors = ['#ff3b30','#ff9500','#ffcc00','#34c759','#0a84ff','#af52de'];
      for (let i=0;i<60;i++){
        const c = document.createElement('div'); c.className = 'confetti-piece';
        c.style.left = (rand(0,100)) + 'vw';
        c.style.top = (rand(-20,10)) + 'vh';
        c.style.background = colors[i%colors.length];
        c.style.transform = `rotate(${rand(0,360)}deg)`;
        c.style.animationDelay = `${rand(0,400)}ms`;
        c.style.width = `${rand(6,12)}px`;
        c.style.height = `${rand(10,20)}px`;
        c.style.opacity = `${rand(0.8,1)}`;
        celebrateRoot.appendChild(c);
      }
      // remove after a while
      setTimeout(()=>{ celebrateRoot.style.display='none'; celebrateRoot.innerHTML=''; }, 2800);
    }

    // ===================== Mode Management =====================
    function setMode(mode) {
      localStorage.setItem(`cube.session.${currentMode}`, JSON.stringify(session));
      localStorage.setItem('cube.mode', mode);
      currentMode = mode; session = JSON.parse(localStorage.getItem(`cube.session.${currentMode}`) || '[]');
      document.querySelectorAll('.mode-btn').forEach(btn => { btn.classList.toggle('active', btn.dataset.mode === mode); });
      patternSection.classList.toggle('active', mode === 'pattern');
      currentModeEl.textContent = mode === 'pattern' ? 'パターン' : '通常';
      renderTimes(); renderAnalysis(); generateNew();
    }

    function setDifficulty(difficulty) {
      currentDifficulty = difficulty; localStorage.setItem('cube.diff', difficulty);
      document.querySelectorAll('.difficulty-btn').forEach(btn => { btn.classList.toggle('active', btn.dataset.difficulty === difficulty); });
      if (currentMode === 'pattern') generateNew();
    }

    let hintOpen = false;
    document.getElementById('btnHint').addEventListener('click', ()=>{ hintOpen = !hintOpen; el('hintBox').style.display = hintOpen ? 'block' : 'none'; });

    const practiceSel = document.getElementById('practiceSet'); practiceSel.value = practiceSet;
    practiceSel.addEventListener('change', ()=>{ practiceSet = practiceSel.value; localStorage.setItem('cube.practiceSet', practiceSet); if (currentMode==='pattern') generateNew(); });

    // ===================== Timer =====================
    function averageOf(n){ if (session.length < n) return null; const lastN = session.slice(-n).map(t=>t.ms).slice(); lastN.sort((a,b)=>a+b,0); const trimmed = lastN.slice(1, -1); const avg = trimmed.reduce((a,b)=>a+b,0) / trimmed.length; return avg; }

    function tick(){
      if (state === 'running'){
        const ms = performance.now() - t0; big.textContent = fmt(ms); raf = requestAnimationFrame(tick);
      } else if (state === 'inspect'){
        const remain = Math.max(0, inspectEnd - performance.now());
        big.textContent = (remain/1000).toFixed(1);
        if (Math.abs(remain - 7000) < 20 || Math.abs(remain - 3000) < 20) { beeper.beep(880, 90); big.classList.add('beep'); setTimeout(()=>big.classList.remove('beep'), 120); }
        if (remain <= 0){ startRun(); }
        raf = requestAnimationFrame(tick);
      }
    }

    function startRun(){ state = 'running'; big.classList.remove('inspect'); t0 = performance.now(); beeper.beep(660, 90); cancelAnimationFrame(raf); raf = requestAnimationFrame(tick); }

    function stopRun(){
      if (state !== 'running') return; state = 'idle'; cancelAnimationFrame(raf); const ms = performance.now() - t0; big.textContent = fmt(ms);
      // detect PB / goal BEFORE adding to session
      const prevBest = session.length ? Math.min(...session.map(s=>s.ms)) : Infinity;
      const isPB = ms < prevBest;
      const isGoal = !isNaN(goalTime) && (ms/1000) <= goalTime;

      const record = { ms, at: Date.now() };
      if (currentMode === 'normal') { record.scramble = currentScramble; record.challenge = currentScramble; }
      else { record.scramble = currentScramble; record.pattern = currentPattern; record.difficulty = currentDifficulty; record.challenge = practiceSet==='free'?`パターン(${currentDifficulty})`:`${practiceSet.toUpperCase()} ケース`; }
      session.push(record); localStorage.setItem(`cube.session.${currentMode}`, JSON.stringify(session));
      // PB storage
      recordPBIfNeeded(ms);
      renderTimes(); renderAnalysis(); beeper.beep(520, 90); 

      // Celebrate
      if (celebrateOn && isPB){ showCelebration('🎉 NEW PB! 🎉'); }
      else if (celebrateOn && isGoal){ showCelebration('🏁 目標達成！おめでとう！'); }

      generateNew();
    }

    function enterHold(){ if (state !== 'idle') return; state = 'hold'; big.classList.remove('inspect'); big.classList.remove('ready'); holdTimer = setTimeout(()=>{ if (state==='hold'){ state='ready'; big.classList.add('ready'); } }, 500); }

    function releaseFromHold(){ clearTimeout(holdTimer); if (state === 'ready'){ big.classList.remove('ready'); if (inspectOn){ state = 'inspect'; big.classList.add('inspect'); inspectEnd = performance.now() + 15000; beeper.beep(1000, 80); cancelAnimationFrame(raf); raf = requestAnimationFrame(tick); } else { startRun(); } } else if (state === 'hold'){ state = 'idle'; } }

    // ===================== Events =====================
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (e.code === 'Space'){
        e.preventDefault(); if (state === 'running') { stopRun(); return; } if (state === 'inspect') { startRun(); return; } enterHold();
      } else if (e.key === 'n' || e.key === 'N'){ generateNew(); }
      else if (e.key === 't' || e.key === 'T'){ setInspect(!inspectOn); }
      else if (e.key === 'd' || e.key === 'D'){ deleteLast(); }
      else if (e.key === 'r' || e.key === 'R'){ clearSession(); }
    });

    document.addEventListener('keyup', (e) => { if (e.code === 'Space'){ e.preventDefault(); if (state === 'hold' || state === 'ready') releaseFromHold(); } });

    const timerArea = document.querySelector('.timer');
    if (timerArea) {
      timerArea.addEventListener('pointerdown', (e) => { if (e.pointerType === 'mouse' && e.button !== 0) return; e.preventDefault(); if (state === 'running') { stopRun(); return; } if (state === 'inspect') { startRun(); return; } enterHold(); });
      timerArea.addEventListener('pointerup', (e) => { e.preventDefault(); if (state === 'hold' || state === 'ready') releaseFromHold(); });
      timerArea.addEventListener('pointercancel', () => { clearTimeout(holdTimer); if (state === 'hold') state = 'idle'; });
      timerArea.addEventListener('pointerleave', () => { if (state === 'hold') { clearTimeout(holdTimer); state = 'idle'; } });
    }

    document.querySelectorAll('.mode-btn').forEach(btn => { btn.addEventListener('click', () => setMode(btn.dataset.mode)); });
    document.querySelectorAll('.difficulty-btn').forEach(btn => { btn.addEventListener('click', () => setDifficulty(btn.dataset.difficulty)); });

    function deleteLast(){ if (!session.length) return; session.pop(); localStorage.setItem(`cube.session.${currentMode}`, JSON.stringify(session)); renderTimes(); renderAnalysis(); drawChart(); }
    function clearSession(){ if (!confirm('セッションをすべて削除しますか？')) return; session = []; localStorage.setItem(`cube.session.${currentMode}`, JSON.stringify(session)); renderTimes(); renderAnalysis(); drawChart(); }

    // Buttons
    el('btnNew').onclick = generateNew;
    el('btnToggleInsp').onclick = () => setInspect(!inspectOn);
    el('btnDelete').onclick = deleteLast;
    el('btnClear').onclick = clearSession;
    el('btnExport').onclick = () => {
      const headers = ['index','time_ms','time_s','mode','challenge','scramble','difficulty','timestamp'];
      const rows = [headers].concat(session.map((t,i) => [ i+1, t.ms, (t.ms/1000).toFixed(3), currentMode, `"${t.challenge || t.scramble}"`, `"${t.scramble||''}"`, t.difficulty || '', new Date(t.at).toISOString() ]));
      const csv = rows.map(r=>r.join(',')).join('\n'); dl(`cube_session_${currentMode}.csv`, csv);
    };

    // Init
    function init(){
      setInspect(inspectOn);
      // restore difficulty button state
      document.querySelectorAll('.difficulty-btn').forEach(btn => { btn.classList.toggle('active', btn.dataset.difficulty === currentDifficulty); });
      // mode
      setMode(currentMode);
      // first chart draw after layout
      setTimeout(drawChart, 0);
      window.addEventListener('resize', drawChart);
    }
    init();
  </script>
</body>
</html>
